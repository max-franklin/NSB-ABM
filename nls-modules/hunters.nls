to setup
  reset-ticks
  kill-caribou
  kill-hunters
  ask patches [ set pcolor green ]
  ask patch 0 0 [ set pcolor black ]
  kill-caribou
  new-caribou
  new-hunters
  ask hunters [ set home-patch ( patch 0 0 )]
end

to go
  tick
  go-caribou
  ask hunters
  [
    ifelse ( hunter-energy > 0 )
    [
      ifelse (prey-caught = false)
      [
       hunt-funct
       explore-funct
       set hunter-energy (hunter-energy - 1)
      ]
      [return-home]
    ]
    [ return-home ]

  ]
end

to set-FCM
  set global-fcm-matrix matrix:from-row-list [[ 0  0  1 -1  0  0 ]
                                              [ 0  0 -1  1  0  0 ]
                                              [ 0  0  0  0  1  0 ]
                                              [ 0  0  0  0  0  1 ]
                                              [ 0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0 ]]
  set global-fcm-internal matrix:submatrix global-fcm-matrix 0 2 2 4
  set global-fcm-motor matrix:submatrix global-fcm-matrix 2 4 4 6
end

to set-hunter-FCMs
  ask hunters
  [
    set hunter-fcm-matrix global-fcm-matrix
    set hunter-fcm-internal global-fcm-internal
    set hunter-fcm-motor global-fcm-motor
  ]
end

to go-hunters
     ifelse ( ticks mod 2 = 0 )
     [ random-walk ]
     [ straight-walk ]
end

to go-caribou-rand
  ask caribou
  [
     ifelse ( ticks mod 2 = 0 )
     [ random-walk ]
     [ straight-walk ]
  ]
end

to-report ternary-funct [ low high sense]
  if ( sense < low )
  [ report 0 ]
  if ( sense > high )
  [ report high ]
  if ( sense >= low and sense <= high )
  [ report (( sense - low ) / ( high - sense )) ]
end

to-report logistic-funct [ x ]
  report ( 1 / ( 1 + e ^ ( -1 * x )))
end

;MAKE NEW CARIBOU POPULATION
to new-caribou
  reset-ticks
  create-caribou caribou-population
  [
    set color white; - 2 + random 5  ;; random shades look nice
    set size 1.25  ;; easier to see
    let done false
    let x 0
    let y 0
    while [done != true]
    [
       set x random-xcor
       set y random-ycor
       ask patch-at x y
       [
         if (patch x y != nobody)
         [
           set done true
         ]
       ]
    ]
    setxy x y
  ]
end

to new-hunters
  create-hunters hunter-population
  [
    set color blue; - 2 + random 5  ;; random shades look nice
    set size 1.75  ;; easier to see
    set hunter-energy 1000
    set prey-caught false
    let done false
    let x 0
    let y 0
    while [done != true]
    [
       set x random-xcor
       set y random-ycor
       ask patch-at x y
       [
         if (patch x y != nobody)
         [
           set done true
         ]
       ]
    ]
    setxy x y
  ]
end

to kill-caribou
  ask caribou [ die ]
end

to kill-hunters
  ask hunters [ die ]
end

;REST
to rest
  rt random-float 360
end

;RANDOM WALK
to random-walk
  rt random-float 360
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [random-walk]
end

;STRAIGHT WALK
to straight-walk
  let right-turn 0
  let left-turn 0
  set right-turn random-float 5
  set left-turn random-float 5
  make-turn right-turn left-turn
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [straight-walk]
end

;MAKE TURN
; turn right or left based on the larger turn angle
to make-turn [rturn lturn]  ; turtle procedure
  ;et turn (rturn - lturn)
  ifelse rturn > lturn
  [ rt rturn ]
  [ lt lturn ]
end


to hunt-funct
  set prey one-of caribou in-radius hunter-vision
  if prey != nobody
  [
      set heading towards prey
      set catch-probability ( random-float 1 )
      if catch-probability >= 0.5
      [ ask prey [ die ]
        set prey-caught true
      ]
      fd 1

  ]
end

to explore-funct
  go-hunters
  ;set hunter-energy (hunter-energy - 1)
end

to return-home
  set heading towards home-patch
  fd 1
  if ( patch-here = home-patch and hunter-energy = 0 ) [ die ]
end
