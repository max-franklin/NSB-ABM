;TODO: NEW SENSORY INPUTS AND MOTOR FUNCITONS 
extensions [ matrix ]
;GLOBAL
globals [
          global-fcm-matrix
          global-fcm-internal
          global-fcm-motor
        ]
;CARIBOU
breed [ caribou a-caribou ]

;HUNTERS
breed [ hunters hunter ]
hunters-own [
             ;concepts
             prey-close      ;from 0:3/5 of hunter vision, activator of hunting
             prey-far        ;from 2/5:5/5 of hunter vision, activator of exploring
             stalking        ;level of internal concept
             curiousity      ;level of internal concept
             hunting         ;hunting function
             exploring       ;exploring function
             ;FCM
             hunter-fcm-matrix
             hunter-fcm-internal
             hunter-fcm-motor
             hunter-fcm-motor-results
             hunter-fcm-sensory
             hunter-fcm-raw-internal
             hunter-fcm-act-internal
             ;data
             prey
             distance-to-prey
             hunter-energy
             home-patch
             catch-probability
             prey-caught
             sensory-close
             sensory-far
             motor-concept-index
             ;prints
             sensory-print
             internal-print
             raw-internal-print
             act-internal-print
             motor-print
             motor-results-print
            ]
caribou-own [  ]

to setup
  reset-ticks
  kill-caribou
  kill-hunters
  ask patches [ set pcolor green ]
  ask patch 0 0 [ set pcolor black ]
  kill-caribou
  new-caribou
  new-hunters
  set-FCM
  ask hunters
  [
    set home-patch ( patch 0 0 )
    set-hunter-FCMs
  ]
  
end

to go
  tick
  go-caribou
  ask hunters
  [
    go-hunters
  ifelse prey-caught = false
  [ execute-FCM ]
  [ return-home ]
  ]
end

to go-hunters
     ifelse ( ticks mod 2 = 0 )
     [ random-walk ]
     [ straight-walk ]
     spend-hunter-energy
end

to go-caribou
  ask caribou
  [
     ifelse ( ticks mod 2 = 0 )
     [ random-walk ]
     [ straight-walk ]
  ]
end

;MAKE NEW CARIBOU POPULATION
to new-caribou
  reset-ticks
  create-caribou caribou-population
  [
    set color white
    set size 1.25 
    let done false
    let x 0
    let y 0
    while [done != true]
    [
       set x random-xcor
       set y random-ycor
       ask patch-at x y
       [
         if (patch x y != nobody)
         [
           set done true
         ]
       ]
    ]
    setxy x y
  ]
end

;NEW HUNTERS 
to new-hunters
  create-hunters hunter-population
  [
    set color blue
    set size 1.75  
    set hunter-energy 1000
    set prey-close (prey-close-constant * hunter-vision)
    set prey-far (prey-far-constant * hunter-vision)
    set prey-caught false
    let done false
    let x 0
    let y 0
    while [done != true]
    [
       set x random-xcor
       set y random-ycor
       ask patch-at x y
       [
         if (patch x y != nobody)
         [
           set done true
         ]
       ]
    ]
    setxy x y
  ]
end

to kill-caribou
  ask caribou [ die ]
end

to kill-hunters
  ask hunters [ die ]
end

;REST
to rest
  rt random-float 360
end

;RANDOM WALK
to random-walk
  rt random-float 360
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [random-walk]
end

;STRAIGHT WALK
to straight-walk
  let right-turn 0
  let left-turn 0
  set right-turn random-float 5
  set left-turn random-float 5
  make-turn right-turn left-turn
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [straight-walk]
end

;MAKE TURN
; turn right or left based on the larger turn angle
to make-turn [rturn lturn]  ; turtle procedure
  ;et turn (rturn - lturn)
  ifelse rturn > lturn
  [ rt rturn ]
  [ lt lturn ]
end

to set-FCM
  set global-fcm-matrix matrix:from-row-list [[ 0  0  1 -1  0  0 ]
                                              [ 0  0 -1  1  0  0 ]
                                              [ 0  0  0  0  1  0 ]
                                              [ 0  0  0  0  0  1 ]
                                              [ 0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0 ]]
  set global-fcm-internal matrix:submatrix global-fcm-matrix 0 2 2 4
  set global-fcm-motor matrix:submatrix global-fcm-matrix 2 4 4 6
end

to set-hunter-FCMs
    set hunter-fcm-matrix global-fcm-matrix
    set hunter-fcm-sensory matrix:from-row-list [[0][0]]
    set hunter-fcm-internal global-fcm-internal
    set hunter-fcm-motor global-fcm-motor 
end

to set-FCM-matrices
  ask hunters
  [
   set hunter-fcm-sensory matrix:from-row-list [[0][0]]
   set hunter-fcm-internal matrix:from-row-list [[1 -1][-1 1]]
   set hunter-fcm-motor matrix:from-row-list [[1 0][0 1]]
  ]
end

to set-hunter-fcm-sensory
  set sensory-close (1 - (ternary-funct prey-close prey-far distance-to-prey))
  set sensory-far ternary-funct prey-close prey-far distance-to-prey
  matrix:set hunter-fcm-sensory 0 0 sensory-close
  matrix:set hunter-fcm-sensory 1 0 sensory-far
  
  set sensory-print matrix:pretty-print-text hunter-fcm-sensory
end

to set-hunter-fcm-raw-internal
  set hunter-fcm-raw-internal matrix:times hunter-fcm-internal hunter-fcm-sensory
  
  set internal-print matrix:pretty-print-text hunter-fcm-internal
  set raw-internal-print matrix:pretty-print-text hunter-fcm-raw-internal
end

to set-hunter-act-internal
  set hunter-fcm-act-internal matrix:map logistic-funct hunter-fcm-raw-internal
  
  set act-internal-print matrix:pretty-print-text hunter-fcm-act-internal
end

to set-hunter-fcm-motor
  set hunter-fcm-motor-results matrix:times hunter-fcm-motor hunter-fcm-act-internal
  
  set motor-print matrix:pretty-print-text hunter-fcm-motor
  set motor-results-print matrix:pretty-print-text hunter-fcm-motor-results
end

to set-motor-concept
  let mat-dims matrix:dimensions hunter-fcm-motor-results
  let num-rows item 0 mat-dims
  let num-cols item 1 mat-dims
  print "Number of rows: "
  print num-rows
  print "Number of columns: "
  print num-cols
  let i 0
  set motor-concept-index 0
  let motor-max 0
  let matrix-temp 0
  while [ i < num-rows ]
  [
     set matrix-temp matrix:get hunter-fcm-motor-results i 0
     if ( matrix-temp > motor-max )
     [
       set motor-max matrix-temp
       set motor-concept-index i
     ]
     set i ( i + 1 )
  ]
  print "Motor matrix max: "
  print motor-max
  print "Concept index: "
  print motor-concept-index
end

to run-motor-function
  ifelse motor-concept-index = 0
  [
    set hunting true
    print "Hunting...\n"
    hunt-funct
  ]
  [
    set exploring true
    print "Exploring...\n"
    explore-funct
  ]
end

to execute-FCM
    find-prey
    if prey != nobody
    [
       set-distance-to-prey
       set-hunter-fcm-sensory
       set-hunter-fcm-raw-internal
       set-hunter-act-internal
       set-hunter-fcm-motor
       print-matrices
       set-motor-concept
       run-motor-function
    ]

end

to print-matrices 
  print "Sensory matrix: "
  print sensory-print
  print "\nInternal matrix: "
  print internal-print
  print "\nRaw internal matrix: "
  print raw-internal-print
  print "\nActivated internal matrix: "
  print act-internal-print 
  print "\nMotor matrix:"
  print motor-print
  print "\nMotor times activated internal matrix:"
  print motor-results-print
end 

to find-prey
   set prey one-of caribou in-radius hunter-vision
end

to head-towards-prey
   set heading towards prey
end

to catch-prey
   set catch-probability ( random-float 1 )
   if catch-probability >= 0.7
   [
     ask prey [ die ]
     set prey-caught true
   ]
end

to move-forward
   fd 1
end

to set-distance-to-prey
   set distance-to-prey distance prey
   print "Distance to prey: "
   print distance-to-prey
end

to hunt-funct
  head-towards-prey
  catch-prey
  move-forward
  spend-hunter-energy
end

to explore-funct
  go-hunters
end

to return-home
  set heading towards home-patch
  move-forward 
  spend-hunter-energy
  if ( patch-here = home-patch and hunter-energy = 0 ) [ die ]
end

to spend-hunter-energy 
  set hunter-energy (hunter-energy - 1)
end 

to-report ternary-funct [ low high sense]
  if ( sense < low )
  [ report 0 ]
  if ( sense > high )
  [ report 1 ]
  report (( sense - low ) / ( high - low )) 
end

to-report logistic-funct [ x ]
  report ( 1 / ( 1 + e ^ ( -1 * x )))
end
