
;GLOBAL
globals [
          ;matrices
          global-fcm-matrix
          global-fcm-sensory
          global-fcm-internal
          global-fcm-motor
          ;prints
          global-full-print
          global-sensory-print
          global-internal-print
          global-motor-print
          
          num-harvests-global
          home-patch-global
        ]

;HUNTERS
hunters-own [
             ;concepts
             prey-close      ;sensory 
             prey-far        
             energy-low
             energy-high 
             boat-and-hike-long
             boat-and-hike-short
             caribou-harvest-low 
             caribou-harvest-high 
             hunter-density-low 
             hunter-density-high
              
             hunting         ;internal
             exploration    
             weakness
             strength   
             off-boat
             on-boat
             lacking
             success 
             
             hunt            ;motor
             foot-travel
             boat-travel       
             return 
             
             ;FCM
             hunter-fcm-matrix
             hunter-fcm-internal
             hunter-fcm-motor
             hunter-fcm-motor-results
             hunter-fcm-sensory
             hunter-fcm-raw-internal
             hunter-fcm-act-internal  
             hunter-fcm-sensory-test
             
             ;data
             boat-return 
             return-to-river
             current-state
             prev-motor-state
             distance-to-prey
             surrounding-hunters
             trip-length 
             travel-heuristic 
             harvest-amount
             hunter-density 
             sensory-prey-close
             sensory-prey-far 
             sensory-enery-low 
             sensory-energy-high 
             sensory-boat-and-hike-long
             sensory-boat-and-hike-short
             sensory-caribou-harvest-low 
             sensory-caribou-harvest-high 
             sensory-hunter-density-low 
             sensory-hunter-density-high 
             motor-concept-index
             target-river-centroid
             target-land-centroid
             target-river-patch
             target-river-patch-r
             home-centroid
             river-to-follow
             river-memory
             river-p
             land-p
             prey
             home-patch
             catch-probability
             prey-caught
             wetness-sum 
             patch-sum
             boat-speed 
             hike-speed
             initial-hike-time
             spent-time 
             boat-dist
             hike-dist-0
             hike-dist-1
             boat-t
             hike-t-0
             hike-t-1
             
             sensory-print
             internal-print
             raw-internal-print
             act-internal-print
             motor-print
             motor-results-print
             num-rows-h
             num-cols-h
             motor-max
            ]

to setup-hunter-nls
  reset-ticks
  kill-caribou
  kill-hunters
  initialize-FCM-hunters
  new-hunters
end

to go-hunters-nls
  ask hunters 
  [
    ;if (trip-length < 1) [ die ]
    execute-FCM 
  ]
end

;NEW HUNTERS
to new-hunters
  create-hunters hunter-population
  [
    set color white
    set size 3
    setxy 3 1
    set boat-speed 30
    set hike-speed 5
    set river-memory []
    set home-patch patch-here
    set trip-length initial-trip-length
    set spent-time 0
    set harvest-amount 0
    set hunter-density 0
    set patch-sum 0
    set-hunter-sensory-ranges
    ;print-hunter-matrices
    set-initial-centroids
    set prey-caught false
    set return false 
    let done false
    set return-to-river false
    set-hunter-FCMs
  ]
  set home-patch-global patch 3 1
end

to set-hunter-sensory-ranges 
    set prey-close (prey-close-constant * hunter-vision)
    set prey-far (prey-far-constant * hunter-vision)
    
    set energy-low (energy-low-constant * initial-trip-length)
    set energy-high (energy-high-constant * initial-trip-length) 
    
    set boat-and-hike-long (boat-hike-long-constant * 1) 
    set boat-and-hike-short (boat-hike-short-constant * 1)
    
    set caribou-harvest-low (caribou-harvest-low-constant * hunter-harvest-goal)
    set caribou-harvest-high (caribou-harvest-high-constant * hunter-harvest-goal)
    
    set hunter-density-low (hunter-density-low-constant * maximum-hunter-density)
    set hunter-density-high (hunter-density-high-constant * maximum-hunter-density)
end 


to initialize-FCM-hunters
  set global-fcm-matrix matrix:from-row-list [[ 0  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1 -1  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1 -1 -1  2 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1 -1 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1 -1  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  1.75 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0 -1 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]
                                              [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]]
  
  set global-fcm-sensory matrix:from-row-list [[ 0  0  0  0  0  0  0  0  0  0]]
  set global-fcm-internal matrix:submatrix global-fcm-matrix 0 10 10 18
  set global-fcm-motor matrix:submatrix global-fcm-matrix 10 18 18 22
  
  set global-full-print matrix:pretty-print-text global-fcm-matrix
  set global-sensory-print matrix:pretty-print-text global-fcm-sensory
  set global-internal-print matrix:pretty-print-text global-fcm-internal
  set global-motor-print matrix:pretty-print-text global-fcm-motor
  
  print-global-matrices
end

to set-hunter-FCMs
    set hunter-fcm-matrix global-fcm-matrix
    set hunter-fcm-sensory global-fcm-sensory
    set hunter-fcm-sensory-test hunter-fcm-sensory
    set hunter-fcm-internal global-fcm-internal
    set hunter-fcm-motor global-fcm-motor
    set sensory-print matrix:pretty-print-text hunter-fcm-sensory
    set internal-print matrix:pretty-print-text hunter-fcm-internal
    set motor-print matrix:pretty-print-text hunter-fcm-motor
end

to set-hunter-fcm-sensory
  set sensory-prey-close (1 - (ternary-funct prey-close prey-far distance-to-prey))
  set sensory-prey-far  ternary-funct prey-close prey-far distance-to-prey
  
  set sensory-enery-low (1 - (ternary-funct energy-low energy-high trip-length))
  set sensory-energy-high ternary-funct energy-low energy-high trip-length 
  
  set sensory-boat-and-hike-short ternary-funct boat-and-hike-short boat-and-hike-long travel-heuristic 
  set sensory-boat-and-hike-long (1 - (ternary-funct boat-and-hike-short boat-and-hike-long travel-heuristic))
  
  set sensory-caribou-harvest-low (1 - (ternary-funct caribou-harvest-low caribou-harvest-high harvest-amount))
  set sensory-caribou-harvest-high ternary-funct caribou-harvest-low caribou-harvest-high harvest-amount 
  
  set sensory-hunter-density-low (1 - (ternary-funct hunter-density-low hunter-density-high hunter-density))
  set sensory-hunter-density-high ternary-funct hunter-density-low hunter-density-high hunter-density 
  
  matrix:set hunter-fcm-sensory 0 0 sensory-prey-close
  matrix:set hunter-fcm-sensory 0 1 sensory-prey-far 
  matrix:set hunter-fcm-sensory 0 2 sensory-enery-low
  matrix:set hunter-fcm-sensory 0 3 sensory-energy-high
  matrix:set hunter-fcm-sensory 0 4 sensory-boat-and-hike-long
  matrix:set hunter-fcm-sensory 0 5 sensory-boat-and-hike-short 
  matrix:set hunter-fcm-sensory 0 6 sensory-caribou-harvest-low
  matrix:set hunter-fcm-sensory 0 7 sensory-caribou-harvest-high
  matrix:set hunter-fcm-sensory 0 8 sensory-hunter-density-low
  matrix:set hunter-fcm-sensory 0 9 sensory-hunter-density-high 

  set sensory-print matrix:pretty-print-text hunter-fcm-sensory
end


to set-hunter-fcm-raw-internal
  set hunter-fcm-raw-internal matrix:times hunter-fcm-sensory hunter-fcm-internal 

  set internal-print matrix:pretty-print-text hunter-fcm-internal
  set raw-internal-print matrix:pretty-print-text hunter-fcm-raw-internal
end

to set-hunter-act-internal
  set hunter-fcm-act-internal matrix:map logistic-funct hunter-fcm-raw-internal

  set act-internal-print matrix:pretty-print-text hunter-fcm-act-internal
end

to set-hunter-fcm-motor
  set hunter-fcm-motor-results matrix:times hunter-fcm-act-internal hunter-fcm-motor 

  set motor-print matrix:pretty-print-text hunter-fcm-motor
 ; matrix:set hunter-fcm-motor-results 0 3 .75
  set motor-results-print matrix:pretty-print-text hunter-fcm-motor-results

  
end

to set-motor-concept
  let mat-dims matrix:dimensions hunter-fcm-motor-results
  set num-rows-h item 0 mat-dims
  set num-cols-h item 1 mat-dims
  let i 0
  set motor-concept-index 0
  set motor-max 0
  let matrix-temp 0
  while [ i < num-cols-h ]
  [
     set matrix-temp matrix:get hunter-fcm-motor-results 0 i
     if ( matrix-temp > motor-max )
     [
       set motor-max matrix-temp
       set motor-concept-index i
     ]
     set i ( i + 1 )
  ]
end

to run-motor-function
  if motor-concept-index = 0
  [
    ;print prev-motor-state
    if prev-motor-state = 2 [ save-target-river-patch ] ;save closest river patch 
    set prev-motor-state 0
    set foot-travel false
    set boat-travel false
    set return false
    set hunt true
    if(target-river-patch-r != 0)
    [set return-to-river true]
    hunt-funct
  ]
  if motor-concept-index = 1
  [
    ;print prev-motor-state
    if prev-motor-state = 2 [ save-target-river-patch ] ;save closest river patch 
    set prev-motor-state 1
    set hunt false
    set boat-travel false
    set return false
    set foot-travel true
    if(target-river-patch-r != 0)
    [set return-to-river true]
    foot-travel-funct ([patch-here] of target-land-centroid)
  ]
  if motor-concept-index = 2 ;CHECK TO RETURN BACK TO RIVER PATCH 
  [
    ;print prev-motor-state
    set prev-motor-state 2
    set hunt false
    set foot-travel false
    set return false
    set boat-travel true
    boat-travel-funct target-river-patch-r ;pass in returning patch 
  ]
  if motor-concept-index = 3
  [
    ;print prev-motor-state
    if prev-motor-state = 2 [ save-target-river-patch ]
    set prev-motor-state 3
    set hunt false
    set boat-travel false
    set foot-travel false
    set return true
    if(target-river-patch-r != 0)
    [set return-to-river true]
    return-home
  ]
  
end

to execute-FCM
    find-prey
    set-distance-to-prey
    set-travel-cost-evaluation
    set-hunter-density
    set-hunter-fcm-sensory
    set-hunter-fcm-raw-internal
    set-hunter-act-internal
    set-hunter-fcm-motor
    set-motor-concept
    ;print-hunter-matrices
    run-motor-function
    ;print-trip-length
    spend-trip-length
end

to hunt-funct
  head-towards-prey
  catch-prey
  move-forward
  spend-trip-length
end

to foot-travel-funct [target]
  ifelse(patch-here != target) ;Travel to destination 
  [
     ifelse(member? target neighbors = false)
     [
        set land-p min-one-of neighbors with [ocean = 0 and ( [distance target] of self < [distance target] of myself )] [wetness]
        if(land-p != nobody)
        [
           set wetness-sum (wetness-sum + ([wetness] of land-p))
           set patch-sum (patch-sum + 1)
           face land-p
           move-to land-p
        ]
     ]
     [
        set wetness-sum (wetness-sum + ([wetness] of target))
        set patch-sum (patch-sum + 1)
        face target
        move-to target
     ]
  ]
  [  ;Local search 
     set land-p (one-of neighbors with [[distance target] of self <= local-search-radius and ocean = 0])
     set patch-sum (patch-sum + 1)
     face land-p
     move-to land-p
  ] 
end

to foot-travel-return-funct [target]
  ;print "Foot return."
  if(patch-here != target)
  [
     ifelse(member? target neighbors = false)
     [
        set land-p min-one-of neighbors with [ocean = 0 and ( [distance target] of self < [distance target] of myself )] [wetness]
        if(land-p != nobody)
        [
          set wetness-sum (wetness-sum + ([wetness] of land-p))
          set patch-sum (patch-sum + 1)
          face land-p
          move-to land-p
        ]
     ]
     [
        set wetness-sum (wetness-sum + ([wetness] of target))
        set patch-sum (patch-sum + 1)
        face target
        move-to target
     ]
  ]
end

to boat-travel-funct [target-r]
  if(patch-here = target-r) [set return-to-river false]
  ifelse(return-to-river = false)
   [    
     ifelse(target-r != 0 and member? target-r neighbors)
     [
       face target-r
       move-to target-r
     ]
     [ 
       set river-memory lput patch-here river-memory
       let target neighbors with [connected? = true and not member? self [river-memory] of myself 
                             and (list-intersect ([river-to-follow] of myself) river-set) ] ;and not member of my memory
       set target max-one-of target [elevation]
       carefully [ face target move-to target ];move-to target
       [
         move-to min-one-of neighbors with [(list-intersect ([river-to-follow] of myself) river-set)][pycor] ;;;;;;;;;
         ;move-to min-one-of neighbors [pycor]
         set target neighbors with [connected? = true and not member? self [river-memory] of myself 
                                and (list-intersect ([river-to-follow] of myself) river-set)] 
         set target max-one-of target [elevation]
         if target != NOBODY
         [ face target move-to target ]
       ]
     ]
   ]
   [foot-travel-return-funct target-r]
end 

to boat-travel-return-funct
  ;print "Boat return"
  set river-memory []
  set river-memory lput patch-here river-memory
  let target neighbors with [connected? = true and not member? self [river-memory] of myself and ( [distance home-patch-global] of self < [distance home-patch] of myself )
                             and (list-intersect ([river-to-follow] of myself) river-set)] ;in-radius 2 ;and not member of my memory
  set target min-one-of target [elevation]
  carefully [ face target move-to target ];move-to target
  [
     move-to max-one-of neighbors with [(list-intersect ([river-to-follow] of myself) river-set)] [pycor];min-one-of
     ;move-to max-one-of neighbors [pycor]
     set target neighbors with [connected? = true and not member? self [river-memory] of myself and ( [distance home-patch-global] of self < [distance home-patch] of myself )
                                and (list-intersect ([river-to-follow] of myself) river-set)] ;in-radius 2    
     set target min-one-of target [elevation]
     if target != NOBODY
     [ face target move-to target ]
  ]
end 

to-report list-intersect [list1 list2] ;find intersection between riversets 
  foreach list1 [ if (member? ? list2) [report true] ] 
  report false 
end 


to find-prey
   set prey one-of caribou in-radius hunter-vision
end

to set-hunter-density 
  set hunter-density count hunters in-radius hunter-vision 
end

to head-towards-prey
  if(prey != nobody)[ set heading towards prey ]
end

to catch-prey
   set catch-probability ( random-float 1 )
   if catch-probability >= 0.9
   [
     set prey-caught true
     set num-harvests-global (num-harvests-global + 1)
     set harvest-amount (harvest-amount + 1)
   ]
end

to move-forward
   fd 1
   set wetness-sum (wetness-sum + ([wetness] of patch-here))
   set patch-sum (patch-sum + 1)
end

to set-distance-to-prey
   ifelse prey != nobody
   [
     set distance-to-prey distance prey
   ]
   [
     set distance-to-prey (hunter-vision + 1) 
   ]
end

to set-travel-cost-evaluation 
  set boat-dist (distance target-river-patch)                              ;distance to river patch
  set hike-dist-0 (distance target-land-centroid)                          ;distance from me to destination
  set hike-dist-1 [distance [target-land-centroid] of myself] of target-river-patch    ;distance from river patch to destination 
  set boat-t (boat-dist / boat-speed)                                      ;time to boat to river patch
  set hike-t-0 (hike-dist-0 / hike-speed)                                  ;time to hike from me to destination 
  set hike-t-1 (hike-dist-1 / hike-speed) 
  ifelse(hike-t-0 != 0)                                 ;time to hike from river patch to destination 
  [set travel-heuristic (hike-t-0 - (boat-t + hike-t-1)) / hike-t-0]
  [set travel-heuristic 0]
end

to explore-funct
  go-hunters
end

to return-home
  ifelse(target-river-patch-r != 0)
  [
    if(patch-here = target-river-patch-r) [set boat-return true]
    ifelse(boat-return = true)
       [boat-travel-return-funct]
       [foot-travel-return-funct target-river-patch-r]
    spend-trip-length
  ]
  [ 
    foot-travel-return-funct home-patch 
    spend-trip-length
  ]
end

to spend-trip-length
  set trip-length (trip-length - 1)
  set spent-time (spent-time + 1)
end

to print-trip-length 
  print "Trip length:"
  print trip-length   
end 

to check-target-river-centroid ;check the centroid you're at for the target 
   if (member? target-river-centroid caribou-harvests in-radius (.25 * hunter-vision));centroids-here != nobody or 
   [ 
      ask target-river-centroid [ ht ]  
      set river-memory []
      set target-river-centroid home-centroid
   ]
end

to set-target-land-centroid ;set the land destination 
   set target-land-centroid one-of caribou-harvests with [frequency-rank < hunter-centroid-selection]
  ; ask target-land-centroid [ st ] 
end

to set-target-river
   set target-river-patch min-one-of patches with [connected? = true and empty? river-set = false] [distance [target-land-centroid] of myself]
   set river-to-follow [river-set] of target-river-patch
end

to set-initial-centroids ;initialize centroids 
   set home-centroid min-one-of caribou-harvests [distance myself] 
   set-target-land-centroid 
   set-target-river
end

to save-target-river-patch 
  set target-river-patch-r min-one-of patches with [connected? = true and empty? river-set = false] [distance myself]
end

to-report ternary-funct [ low high sense]
  if ( sense < low )
  [ report 0 ]
  if ( sense > high )
  [ report 1 ]
  report (( sense - low ) / ( high - low ))
end

to-report logistic-funct [ x ]
  report ( 1 / ( 1 + e ^ ( -1 * x )))
end

to kill-caribou
  ask caribou [ die ]
end

to kill-hunters
  ask hunters [ die ]
end

;REST
to rest
  rt random-float 360
end


to print-hunter-matrices
  print "Sensory matrix:"
  print sensory-print
  print "\nInternal matrix:"
  print internal-print
  print "\nRaw internal matrix:"
  print raw-internal-print
  print "\nActivated internal matrix:"
  print act-internal-print
  print "\nMotor matrix:"
  print motor-print
  print "\nMotor times activated internal matrix:"
  print motor-results-print
  print "Motor matrix max:"
  print motor-max
  print "Concept index:"
  print motor-concept-index
end

to print-global-matrices 
  print "Full FCM:" 
  print global-full-print
  print "Global sensory matrix:"
  print global-sensory-print
  print "Global internal matrix:"
  print global-internal-print
  print "Global motor matrix:"
  print global-motor-print
end

;RANDOM WALK
to random-walk
  rt random-float 360
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [random-walk]
end

;STRAIGHT WALK
to straight-walk
  let right-turn random-float 5
  let left-turn random-float 5
  make-turn right-turn left-turn
  let done false
  if (patch-ahead 1 != nobody)
  [
    set done true
  ]
  ifelse done = true
  [fd 1]
  [straight-walk]
end

;MAKE TURN
; turn right or left based on the larger turn angle
to make-turn [rturn lturn]  ; turtle procedure
  ifelse rturn > lturn
  [ rt rturn ]
  [ lt lturn ]
end

to go-hunters
     ifelse ( ticks mod 4 = 0 )
     [ random-walk ]
     [ straight-walk ]
     spend-trip-length
end

to go-caribou-hunter-nls
  ask caribou
  [
     ifelse ( ticks mod 4 = 0 )
     [ random-walk ]
     [ straight-walk ]
  ]
end

;MAKE NEW CARIBOU POPULATION
to new-caribou
  reset-ticks
  create-caribou 0;caribou-population-hunter-nls
  [
    set color white
    set size 1.25
    let done false
    let x 0
    let y 0
    while [done != true]
    [
       set x random-xcor
       set y random-ycor
       ask patch-at x y
       [
         if (patch x y != nobody)
         [
           set done true
         ]
       ]
    ]
    setxy x y
  ]
end
