globals [
 
 car-var-soln-fit-list
 car-var-soln-list 
  
]

to setup-caribou-var-cal 
  ;print "this is a test to see if setup-car-var-cal is being called"
  set caribouVarCal [ ] 
  ifelse randomCaribouVarStart?
    [
      ;print "testing to see if random assignment occurs."
      ;;need to do: check to see if any division by zero errors will occur in caribou utility functions due to random number gen.
      repeat 9 [
        ;;from left to right, the variables are: decay-rate, energy-gain, ndvi-weight, caribou-veg-factor, caribou-rough-factor, caribou-insect-factor,
        ;;caribou-modifier-factor, caribou-deflection-factor, caribou-precip-factor.
        set caribouVarCal lput random-num 1 caribouVarCal
      ]
    ]
    [
      ;;set caribouVarCal starting values..
      set caribouVarCal lput decay-rate caribouVarCal
      set caribouVarCal lput energy-gain-factor caribouVarCal
      set caribouVarCal lput ndvi-weight caribouVarCal
      set caribouVarCal lput caribou-veg-factor caribouVarCal
      set caribouVarCal lput caribou-rough-factor caribouVarCal
      set caribouVarCal lput caribou-insect-factor caribouVarCal
      set caribouVarCal lput caribou-modifier-factor caribouVarCal
      set caribouVarCal lput caribou-deflection-factor caribouVarCal
      set caribouVarCal lput caribou-precip-factor caribouVarCal
    ]
  
    
  assign-variable-values 
  if exportCaribouData? [ setup-var-file ]
end

to go-caribou-var-cal 
  let oldCaribouVarCal caribouVarCal
  let mutatedVars? 0
  let recombined? 0
  let datIn calculate-var-prob
  let varProb item 0 datIn
  let convergence item 1 datIn
  let soln-success item 2 datIn
  if (random-num 1) <= varProb [ 
    set mutatedVars? 1
    
    ;;create temporary lists without current fitness and soln value for purpose of
    ;;weeding out current soln from recombination pool.
    let t-car-var-soln-fit-list car-var-soln-fit-list 
    let t-car-var-soln-list car-var-soln-list 
    
    set car-var-soln-fit-list lput soln-success car-var-soln-fit-list
    set car-var-soln-list lput caribouVarCal car-var-soln-list 
    
    let recombRoll random-num 1
    if recombRoll > ( soln-success / ( max car-var-soln-fit-list )) [
    ;;recomb caribou variable calibration solutions.
    set recombined? 1
    let var-genome-1 0
    let var-genome-2 0
    
    ;;check to see if we need to search for a cross-over partner, or there's only
    ;;one other solution generated, thus far.
    ifelse length t-car-var-soln-list > 1 
    [
      ;;build a probability list first for weighted selection.
      let prob-recomb-list build-prob-list car-var-soln-fit-list 
      ;;now select one of the list randomly for crossing
      set var-genome-1 select-weighted-val prob-recomb-list t-car-var-soln-list
      set var-genome-2 caribouVarCal
      
    ]
    [
      set var-genome-1 item 0 t-car-var-soln-list
      set var-genome-2 caribouVarCal
    ]
    
    ;;now, we can run the recombination procedure. 
    set caribouVarCal cross-var-genome var-genome-1 var-genome-2
      
    ]
    
    mutate-caribou-variables
  ]
 
  if exportCaribouData? [ export-var-data mutatedVars? recombined? varProb convergence oldCaribouVarCal soln-success ]
end

to-report cross-var-genome [ genome-1 genome-2 ]
  let test? true
  
  let len-snip-1 random (length genome-1)
  let snip-1 sublist genome-1 0 len-snip-1
  
  let snip-2 sublist genome-2 len-snip-1 (length genome-2)
  
  let genome-out snip-1
  foreach snip-2 [
   set genome-out lput item ? snip-2 genome-out
  ]
  
  ;;quickly check to make sure we didn't botch the process..
  if test? [
    show genome-1
    show snip-1
    show genome-2
    show snip-2
    show genome-out
  ]
  
  report genome-out
end

to setup-var-file 
  
  let globalVars [ "decay-rate" "energy-gain" "ndvi-weight" "caribou-veg-factor" "caribou-rough-factor" "caribou-insect-factor" 
    "caribou-modifier-factor" "caribou-deflection-factor" "caribou-precip-factor" ] 
  
  let fileOut "caribou-var-calibration-data-"
  set fileOut word fileOut seed
  set fileOut word fileOut ".txt"
  
  if file-exists? fileOut [ file-delete fileOut ]
  
  file-open fileOut
  
  file-write "year"
  file-write "mean season Bio-E"
  file-write "fcm convergence"
  file-write "probability of mutation"
  file-write "mutated?"
  file-write "recombined?"
  foreach globalVars file-write
  file-write "solution success"
  ;file-print ""
  ;file-write year
  ;file-write 0
  ;file-write 0
  ;file-write 0
  ;file-write 0
  ;foreach caribouVarCal file-write
  ;file-write 0
  
  file-close
end

to export-var-data [ mutatedVars? recombined? varProb convergence oldCaribouVarCal soln-success ]
  let fileOut "caribou-var-calibration-data-"
  set fileOut word fileOut seed
  set fileOut word fileOut ".txt"
  
  ;let convergence length caribou-fcm-adja-list
  ;set convergence 1 - ( convergence / caribou-group-amt )
  
  file-open fileOut
  file-print ""
  ;file-write (year + 1)
  file-write year
  file-write mean [bioenergy-success] of caribou
  file-write convergence
  file-write varProb
  ;;for next two variables, they track with the incoming next line of variable calibration solns.
  file-write mutatedVars?
  file-write recombined?
  foreach oldCaribouVarCal file-write 
  file-write soln-success
  file-close 
end

to mutate-caribou-variables 
  ;;for now, just assign a mutate amt.  
  let mutateAmt (random-num 2) - 1
  let randItem (random length caribouVarCal)
  let oldVal item randItem caribouVarCal
  let newVal oldVal + mutateAmt
  
  while [ newVal <= 0 or newVal >= 1 ] [
    set mutateAmt (random-num 2) - 1
    set oldVal item randItem caribouVarCal
    set newVal oldVal + mutateAmt   
  ]
 
  set caribouVarCal replace-item randItem caribouVarCal newVal
  
  assign-variable-values 
  
end

to assign-variable-values 
  let globalVars [ "decay-rate" "energy-gain" "ndvi-weight" "caribou-veg-factor" "caribou-rough-factor" "caribou-insect-factor" 
    "caribou-modifier-factor" "caribou-deflection-factor" "caribou-precip-factor" ] 
  
  set decay-rate item (position "decay-rate" globalVars) caribouVarCal
  set energy-gain-factor ( item (position "energy-gain" globalVars) caribouVarCal ) * 100 
  set ndvi-weight item (position "ndvi-weight" globalVars) caribouVarCal
  set caribou-veg-factor item (position "caribou-veg-factor" globalVars) caribouVarCal
  set caribou-rough-factor item (position "caribou-rough-factor" globalVars) caribouVarCal
  set caribou-insect-factor item (position "caribou-insect-factor" globalVars) caribouVarCal
  set caribou-modifier-factor item (position "caribou-modifier-factor" globalVars) caribouVarCal
  set caribou-deflection-factor item (position "caribou-deflection-factor" globalVars) caribouVarCal
  set caribou-precip-factor item (position "caribou-precip-factor" globalVars) caribouVarCal
end

to-report calculate-var-prob 
  let test? false
  let datOut [ ]
  let convergence length caribou-fcm-adja-list
  set convergence 1 - ( convergence / caribou-group-amt );;divide by initial number of unique caribou FCMs to normalize the variable.
  
  ;;following values = winter energetic loss buffer range taken from Semeniuk et al. 2012 woodland caribou paper.
  let lowE 710000 
  let highE 947000
  let midE (lowE + highE) / 2
  let rng highE - lowE
  let var 1
  let fitness 0
  let avgSeasonE mean [ bioenergy-success ] of caribou
  ;let avgSeasonE lowE
  
  let diff abs(midE - avgSeasonE)
  
  ifelse avgSeasonE <= (highE + (var * rng) ) and avgSeasonE >= (lowE - (var * rng) )
  [
    ;;if E in reasonable range of values, base fitness on how high
    let t (rng / 2) + (var * rng)
    set fitness 1 - ( diff / t )
  ]
  [
    ifelse avgSeasonE > (highE + (var * rng) )
    [
      set fitness 0
    ]
    [
      if avgSeasonE < (lowE - (var * rng) )
      [
        set fitness 0
      ]
    ] 
  ]

  let x 0.5 let y 1
  
  let varProb (y * convergence) - (x * fitness)
  
  if test? [
    print "fitness from caribou seasonal bioE:"
    show fitness
    
    print "convergence:"
    show convergence
    
    print "probability of mutating one of caribou variables:"
    show varProb
  ]
  
  set datOut lput varProb datOut
  set datOut lput convergence datOut
  set datOut lput fitness datOut
  
  report datOut
  
  ;report varProb
  ;report ( 1 - ((x * fitness) + (y * convergence)) )
end

to-report random-num [ num ]
  report random ((num * 1000) + 1) / 1000
end