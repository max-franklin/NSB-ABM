;; FROM-NLS: patch-list.nls : fcm.nls

;to rolling-caribou-setup ;for setting up the caribou agents when the year cycles and when training FCMs.
;  ask caribou [ 
;      set fcm-adja matrix:map mutate-nonzero fcm-adja ;also, don't forget to make a new fcm-adja based on the most succesful fcm-adja (after saving it into fcm-adja-base)
;      ]
;end

to setup-caribou

  
  
  let caribou-group-number floor(caribou-amt / caribou-group-amt)

;  ;set base fcm
;  set base-fcm-caribou matrix:make-identity 7
;  matrix:set-row base-fcm-caribou 0 [0 0 0 0.5 -0.5 0 0] ;util low
;  matrix:set-row base-fcm-caribou 1 [0 0 0 -0.5 0.5 0 0] ;util high
;  matrix:set-row base-fcm-caribou 2 [0 0 0 0 -0.5 0.5 -0.5] ;cent close
;  matrix:set-row base-fcm-caribou 3 [0 0 0 0 0 0 0.5]   ;cent far
;  matrix:set-row base-fcm-caribou 4 [0 0 0 0 0 0 0]
;  matrix:set-row base-fcm-caribou 5 [0 0 0 0 0 0 0]
;  matrix:set-row base-fcm-caribou 6 [0 0 0 0 0 0 0]


  set fcm-adja-base matrix:make-constant 21 11 0
   ;initialize the adjacency list to predefined values
;  matrix:set-row fcm-adja-base 0  [  4  0  0.1  0  -1  1  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 1  [  -4  0  0  0  0.5  -0.5  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 2  [  0  0.5  -0.1  0.1  0.5  -0.5  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 3  [  0  0  0.2  -0.2  -0.7  0.7  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 4  [  0.4  4  0  0  -2.2  2.2  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 5  [  0  -1  0.2  -0.2  1.5  -1.5  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 6  [  0  -0.2  -0.3  0.3  1.1  -1.1  0  0  0  2.6  0  ]
;  matrix:set-row fcm-adja-base 7  [  0  0.2  1  -1  -1.1  1.1  0  0  0  -4  0  ]
;  matrix:set-row fcm-adja-base 8  [  2  0  0  0  -1  1  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 9  [  -2  0  0  0  0.5  -0.5  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 10  [  0.5  0  0  0  0  0  3.5  -0.8  -1  -1  -1  ]
;  matrix:set-row fcm-adja-base 11  [  0  0.3  0  0  0  0  -0.8  2.1  -0.5  4  -1.8  ]
;  matrix:set-row fcm-adja-base 12  [  0  0  0.1  0  0  0  -0.1  0.5  -0.2  -0.3  -0.2  ]
;  matrix:set-row fcm-adja-base 13  [  0  0  0  0.1  0  0  0  -0.5  0.2  0.3  0.2  ]
;  matrix:set-row fcm-adja-base 14  [  0  0  0  0  0  0  -0.1  -0.8  1.5  0.8  0.7  ]
;  matrix:set-row fcm-adja-base 15  [  0  0  0  0  0  0  0.4  1  -1.2  -0.7  -0.7  ]
;  matrix:set-row fcm-adja-base 16  [  0  0  0  0  0  0  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 17  [  0  0  0  0  0  0  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 18  [  0  0  0  0  0  0  0  0  0.2  0  0  ]
;  matrix:set-row fcm-adja-base 19  [  0  0  0  0  0  0  0  0  0  0  0  ]
;  matrix:set-row fcm-adja-base 20  [  0  0  0  0  0  0  0  0  0  0  0  ]
;  
  matrix:set-row fcm-adja-base 0  [  1.00  0.00  0.10  0.00  -1    1.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 1  [  -1    0.00  0.00  0.00  0.50  -0.5  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 2  [  0.00  0.50  -0.1  0.10  0.50  -0.5  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 3  [  0.00  0.00  0.20  -0.2  -0.7  0.70  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 4  [  0.40  1.00  0.00  0.00  -2.2  2.20  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 5  [  0.00  -1    0.20  -0.2  1.50  -1.5  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 6  [  0.00  -0.2  -0.3  0.30  1.10  -1.1  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 7  [  0.00  0.20  1.00  -1    -1.1  1.10  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 8  [  2.00  0.00  0.00  0.00  -1.00  1.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 9  [  -2.00  0.00  0.00  0.00  0.50  -0.50  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 10  [  0.00  0.00  0.00  0.00  0.00  0.00  1.50  -0.8  -1    -1      -1  ]
  matrix:set-row fcm-adja-base 11  [  0.00  0.00  0.00  0.00  0.00  0.00  -0.8  2.10  -0.5  1.00  -1.8  ]
  matrix:set-row fcm-adja-base 12  [  0.00  0.00  0.00  0.00  0.00  0.00  -0.1  0.50  -0.2  -0.3  -0.2  ]
  matrix:set-row fcm-adja-base 13  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  -0.5  0.20  0.30  0.20  ]
  matrix:set-row fcm-adja-base 14  [  0.00  0.00  0.00  0.00  0.00  0.00  -0.1  -0.8  1.50  0.80  0.70  ]
  matrix:set-row fcm-adja-base 15  [  0.00  0.00  0.00  0.00  0.00  0.00  0.40  1.00  -1.2  -0.7  -0.7  ]
  matrix:set-row fcm-adja-base 16  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 17  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 18  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 19  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  ]
  matrix:set-row fcm-adja-base 20  [  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  ]


 set fcm-adja-base matrix:make-constant 21 11 0 ;For making a random map to mutate.
  
  
  create-caribou caribou-group-amt
  [
    ;set grid-memory [ ]
    ;repeat 20 [ set grid-memory lput 0 cent-memory ]
    ;State management
    set last-state-migrate false
    set allowed-to-remember false
    set color blue + 2
    let rxcor random-xcor
    let rycor random-ycor
    let gen-rand (random 100 + 1)
    
    ifelse(gen-rand < 42.5) ; average number bulls per 100 females
    [
      set caribou-class 0
    ]
    [
      set caribou-class 1
    ]
    
    if (caribou-class = 1)
    [
      set gen-rand (random 100 + 1)
      if(gen-rand < (caribou-para * 100))
      [
        set caribou-class 2
      ]
    ]
    
    ;forage intra-patch
    set fga-amt 135 / 2195 ;SemeniukVal * 3 / patch width&height in meters
    ;forage inter-patch
    set fge-amt 1350 / 2195 ; move-towards new patch, set as goal, check if reached, clear goal.
    ;migrate/taxi
    set mg-amt-min 3000 / 2195
    set mg-amt-max 6000 / 2195


    ;fcm setup

    set fcm-mat-sensor matrix:make-constant 10 1 0
    set fcm-mat-conc-delta matrix:make-constant 11 1 0; the stored values for concepts and motor states 1 x 11 (top 6 represent concepts, trailing 5 represent motor states)
    caribou-random-fcm
    set fcm-adja matrix:copy fcm-adja-base ; Adj
    
    ;set fcm-adja matrix:map mutate-nonzero fcm-adja ;mutate the map
    
    mutate-genome

    ;TODO Evaluate real values
    set close-range 1.0;  ex: 1.2
    set far-range 6; ex: 1.8
    set fcm-sigmoid-scalar 1


    ;taxi based on upto 3 patches away


    ;;Attraction factor to migrate
    set attraction-factor 15
    set test-migration 0
    set last-patches array:from-list n-values 45 [0]
    set last-patch-index 0

    set last-taxi-vals array:from-list n-values 10 [0]
    set last-taxi-index 0

    set last-forage-vals array:from-list n-values 10 [0]
    set last-forage-index 0

    ;placement of caribou
    while[rxcor < -63 or rxcor > 63]
    [
      set rxcor random-xcor
    ]

    while[rycor < -63 or rycor > 63]
    [
      set rycor random-ycor
    ]
    ;Size is radius of herd
    set radius caribou-radius
    set shape "circle 2"
    set size radius

    ;set current-centroid one-of centroids

    set centroid-attraction set-centroid-attraction

    set group-size caribou-group-amt
    set fd-amt 0.25 ;place holder overwritten in go-caribou
   while [not check-location rxcor rycor]
   [
     set rxcor random-xcor
     set rycor random-ycor
   ]
    setxy rxcor rycor

    ;set by group population
    set weight (132 * caribou-group-number)
    set bioenergy-success (27.5 * 1000)
    set bioenergy (27.5 * 1000);* caribou-group-number * 1000) ; In kJ
    set bioenergy-upper (33 * 1000) ;caribou-group-number * 1000) ; kJ
    set bioenergy-lower (22 * 1000) ;caribou-group-number) * 1000; kJ

      ;;Edges
  ;array:set graph-edges 0 1.0

;  set cog-map matrix:make-identity 7


  ;;WIP;;
  ;;FCM-caribou end states
  ;Perception
  ; util-low                    ; 0
  ; util-high (inverse of low)  ; 1
  ; cent-close                  ; 2
  ; cent-far                    ; 3
  ;Action
  ; change-cent/taxi state      ; 4
  ; forage-state/               ; 5
  ; cent-attraction             ; 6

;  matrix:set-row cog-map 0 [0 0 0 1 -1 0 0] ;util low
;  matrix:set-row cog-map 1 [0 0 0 -1 1 0 0] ;util high
;  matrix:set-row cog-map 2 [0 0 0 0 -1 1 -1] ;cent close
;  matrix:set-row cog-map 3 [0 0 0 0 0 0 1]   ;cent far
;  matrix:set-row cog-map 4 [0 0 0 0 0 0 0] ;change cent/taxi
;  matrix:set-row cog-map 5 [0 0 0 0 0 0 0] ;forage
;  matrix:set-row cog-map 6 [0 0 0 0 0 0 0] ; cent attraction
;   set cog-map matrix:copy base-fcm-caribou
;
;   let rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 0 3 ((matrix:get cog-map 0 3) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 0 4 ((matrix:get cog-map 0 4) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 1 3 ((matrix:get cog-map 1 3) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 1 4 ((matrix:get cog-map 1 4) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 2 4 ((matrix:get cog-map 2 4) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 2 5 ((matrix:get cog-map 2 5) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 2 6 ((matrix:get cog-map 2 6) + rand)
;
;   set rand (random-float (mutate-amt * 2) - mutate-amt)
;   matrix:set cog-map 3 6 ((matrix:get cog-map 3 6) + rand)

;if(is-training?)
;[
;  setxy -12 -27
;]
;starting centroid is closest centroid
    ;ifelse day > 151 and day < 167 and caribou-class = 2
    ;[ set current-centroid min-one-of patches with [pid > 0] [distance myself]
    ;  set last-centroid current-centroid ]
    ;[ set current-centroid min-one-of patches with [npid > 0] [distance myself]
    ;  set last-centroid current-centroid ]
    ;;starting grid is closest grid
    ;ifelse day > 151 and day < 167 and caribou-class = 2
    ;[ set current-grid min-one-of grids with [p-qual-id > 0] [distance myself]
    ;  set last-grid current-grid ]
    ;[ set current-grid min-one-of grids with [np-qual-id > 0] [distance myself]
    ;  set last-grid current-grid ]
    
    
    ifelse day > 151 and day < 166 and caribou-class = 2
      [ set current-centroid min-one-of patches with [pid > 0] [distance myself]
        set last-centroid patch -64 64 ];current-centroid ]
      [ set current-centroid min-one-of patches with [npid > 0] [distance myself]
        set last-centroid patch -64 64 ];current-centroid ] ]
                                        ;starting grid is closest grid
    ifelse day > 151 and day < 166 and caribou-class = 2
      [ set current-grid min-one-of grids with [p-qual-id > 0] [distance myself]
        set current-grid [who] of current-grid
        set last-grid 0 ]
      [ set current-grid min-one-of grids with [np-qual-id > 0] [distance myself]
        set current-grid [who] of current-grid
        set last-grid 0 ]  


  ]
end

to go-caribou
  let caribou-group-number floor(caribou-amt / caribou-group-amt)
  
  ;Test migration state, and when to kick out of migration.
  ; Use centroid attraction factor to control intensity of migration
  ; Incorporate FCM for migration decisions.
  
  ;;;States;;;
  ; 0 - intra-forage
  ; 1 - taxi
  ; 2 - interforage
  
  
  
  ;actVals
  ;util-low
  ;util-high
  ;taxi-state
  ;forage-state
  ;cent-dist-close
  ;cent-dist-far
  
  ;fcm-mat-sensor ;sensor values placed into a matrix representing the previous values
  ;fcm-mat-conc-delta ; the stored values for concepts and motor states 1 x 11 (top 6 represent concepts, trailing 5 represent motor states)
  ;fcm-adja
  
  
  let high-food-para 0.5 * max [caribou-utility-para] of patches
  let high-food-non-para 0.5 * max [caribou-utility-non-para] of patches
  ask caribou
  [ ;if day = 166 [stop]
    let dist-cent distance current-centroid
    let dist-grid distance grid current-grid
    
    
    set state 2
    let other-state-found false
    let avg-past 0
    ;let energy-loss 0
    set energy-loss 0
    ;close-range ;  ex: 1.2
    ;far-range ; ex: 1.8
    ;fcm-sigmoid-scalar
    
    ;wraps into the ternary function
    
    let close-hunt (min-one-of hunters [distance myself] )
    let hunt-dist distance close-hunt
    matrix:set fcm-mat-sensor 0 0  (1 - (fcm-ternary 0.25 0.75 hunt-dist)) ;Foe Close = 0 invert this valuse
    matrix:set fcm-mat-sensor 1 0 (fcm-ternary 0.25 0.75 hunt-dist) ;Foe Far = 1
    
    ;**************************************************************correct caribou utility logic? *****************************************************************************
    
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-para]) 
      let high-food-dist distance high-food-near
      ;let high-food-threshold 0.5 * max [caribou-utility-para] of patches
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-para] of high-food-near < high-food-para)
      [
        set high-food-dist 129
      ]
      matrix:set fcm-mat-sensor 2 0 (1 - (fcm-ternary 0 3 high-food-dist)) ;food Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 3 0 (fcm-ternary 0 3 high-food-dist) ;Food Far = 1
      
      matrix:set fcm-mat-sensor 4 0 (1 - (fcm-ternary bioenergy-lower bioenergy-upper bioenergy )) 
      matrix:set fcm-mat-sensor 5 0 (fcm-ternary bioenergy-lower bioenergy-upper bioenergy) 
      
      let local-quantity  [caribou-utility-para] of patch-here
      matrix:set fcm-mat-sensor 6 0 (fcm-ternary 0.50 1 local-quantity) ;Foe Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 7 0 (1 - (fcm-ternary 0.50 0 local-quantity)) ;Foe Far = 1
      
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist distance close-hunt
      matrix:set fcm-mat-sensor 8 0 (1 - (fcm-ternary 1 3 disturb-dist)) ;Foe Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 9 0 (fcm-ternary 1 3 disturb-dist) ;Foe Far = 1
    ]
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-non-para])
      let high-food-dist distance high-food-near
      ;let high-food-threshold 0.5 * max [caribou-utility-non-para] of patches
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-non-para] of high-food-near < high-food-non-para)
      [
        set high-food-dist 129
      ]
      matrix:set fcm-mat-sensor 2 0 (1 - (fcm-ternary 0 3 high-food-dist)) ;food Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 3 0 (fcm-ternary 0 3 high-food-dist) ;Food Far = 1
      
      matrix:set fcm-mat-sensor 4 0 (1 - (fcm-ternary bioenergy-lower bioenergy-upper bioenergy ))
      matrix:set fcm-mat-sensor 5 0 (fcm-ternary bioenergy-lower bioenergy-upper bioenergy)
      
      let local-quantity  [caribou-utility-non-para] of patch-here
      matrix:set fcm-mat-sensor 6 0 ((fcm-ternary 0.50 1 local-quantity)) ;Foe Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 7 0 (1 - (fcm-ternary 0.50 0 local-quantity)) ;Foe Far = 1
      
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist distance close-hunt
      matrix:set fcm-mat-sensor 8 0 (1 - (fcm-ternary 1 3 disturb-dist)) ;Foe Close = 0 invert this valuse
      matrix:set fcm-mat-sensor 9 0 (fcm-ternary 1 3 disturb-dist) ;Foe Far = 1
    ]
    
    
    
    
    ;;Sensory Operations
    ;this is the "splice" in the diagram from your notebook to multiply by the submatrix
    ;let fcm-combined-sensor fcm-merge-sen-conc fcm-mat-sensor fcm-mat-conc-delta
    
    ;multiply by sub adjacency list to calculate concepts
    ;show matrix:dimensions matrix:transpose((matrix:submatrix fcm-adja 0 0 16 11))
    ;show matrix:dimensions fcm-combined-sensor
    
    
    
    ;weights for internal concepts
    ;;let sens-adj matrix:transpose(matrix:submatrix fcm-adja 0 0 10 6)
    ;REWORKED
    let fcm-mat-sensor-t matrix:transpose(fcm-mat-sensor)
    let sens-adj matrix:submatrix fcm-adja 0 0 10 6
    
    ;let internal matrix:times sens-adj fcm-mat-sensor
    ;set internal matrix:map fcm-sigmoid-simple internal
    
    let internal matrix:times fcm-mat-sensor-t sens-adj
    set internal matrix:map fcm-sigmoid-simple internal
    
    
    ;weights for actions
    ;let conc-adj matrix:transpose(matrix:submatrix fcm-adja 10 6 16 11) 
    ;let final-states matrix:times conc-adj internal
    let conc-adj matrix:submatrix fcm-adja 10 6 16 11
    let final-states matrix:times internal conc-adj
    
    ;Make compatible with old function
    set final-states matrix:transpose final-states
    set final-states matrix:map fcm-sigmoid-simple final-states
    
    
    if(who = 148 and debug-fcm?)
    [
      print "Initial Sense States"
      print matrix:pretty-print-text fcm-mat-sensor
      print "Concepts"
      print matrix:pretty-print-text internal
      
      print "Results"
      print matrix:pretty-print-text final-states
    ]
    
    set state fcm-index-max final-states
    ;    
    ;    let concept-calc matrix:times matrix:transpose(matrix:submatrix fcm-adja 0 0 16 11) fcm-combined-sensor  ;multiply by the adjacency list for sensors and concepts (internalizations)
    ;    let concept-act fcm-sigmoid-concept-wrapper concept-calc fcm-mat-conc-delta
    ;    let motor-calc matrix:times matrix:transpose(matrix:submatrix fcm-adja 10 0 21 11) concept-act
    ;    let motor-act fcm-sigmoid-concept-wrapper motor-calc fcm-mat-conc-delta
    ;    set fcm-mat-conc-delta motor-act
    ;    set state fcm-index-max motor-act
    
    
    ;
    ;    let i 0
    ;
    ;    while [i < 45]
    ;      [
    ;        set avg-past (avg-past + array:item last-patches i)
    ;
    ;        set i (i + 1)
    ;      ]
    ;
    ;      ;util high or low activation
    ;      ifelse(avg-past < caribou-util-cutoff and ticks > 720)
    ;      [
    ;        set util-low 1
    ;        set util-high 0
    ;
    ;        set taxi-state taxi-state + matrix:get cog-map 1 4
    ;        set forage-state forage-state + matrix:get cog-map 1 3
    ;      ]
    ;      [
    ;       set util-low 0
    ;       set util-high 1
    ;
    ;       set taxi-state taxi-state + matrix:get cog-map 1 4
    ;       set forage-state forage-state + matrix:get cog-map 1 3
    ;      ]
    
    
    ;increase taxi/migration based on high values util values
    
    
    
    ;Centroid Attraction rate
    set magic-centroid current-centroid
    
    let cent-agents centroids with [cid = magic-centroid]
    let cent-agent one-of cent-agents
    let temp-dist (distance current-centroid)
    
    ;      ifelse(temp-dist > caribou-cent-dist-cutoff)
    ;      [
    ;        set cent-dist-close 0
    ;        set cent-dist-far 1
    ;
    ;        set centroid-attraction centroid-attraction-max
    ;      ]
    ;      [
    ;        set cent-dist-close 1
    ;        set cent-dist-far 0
    ;
    ;        set taxi-state taxi-state + matrix:get cog-map 1 4
    ;        set forage-state forage-state + matrix:get cog-map 1 3
    ;
    ;        set centroid-attraction (temp-dist / caribou-cent-dist-cutoff) * centroid-attraction-max
    ;        if(centroid-attraction < centroid-attraction-min)
    ;        [
    ;          set centroid-attraction centroid-attraction-min
    ;        ]
    ;
    ;      ]
    ;      if(taxi-state > 1)
    ;      [
    ;        set taxi-state 1
    ;      ]
    ;
    ;      if(taxi-state < 0)
    ;      [
    ;        set taxi-state 0
    ;      ]
    ;
    ;      ; based on percentages in Semeniuk et al
    ;      ifelse(taxi-state > 0.8)
    ;      [
    ;        ifelse(forage-state > 0.5)
    ;        [
    ;          set state 2
    ;        ]
    ;        [
    ;          set state 1
    ;        ]
    ;      ]
    ;      [
    ;        ifelse(forage-state > 0.5)
    ;        [
    ;          set state 0
    ;        ]
    ;        [
    ;          set state 2
    ;        ]
    ;      ]
    ;
    
    
    
    ;other-state-found used to get around if-else limitations
    if(state = 4) ;intra forage
    [
      set fd-amt fga-amt
      
      set energy-loss  296.1 ; foraging expense (Boertje 1985, 105 kg caribou for 1.5 hr)
      ;set energy-loss  2.82 ; foraging expense
      
      set other-state-found true
    ]
    
    if(state = 2 and not other-state-found);taxi/migrate
    [
      
      ifelse dist-grid <= 1
      [ select-grid 
        select-centroid ]
      [ if dist-cent <= 1
        [select-centroid ]]
      
      
      
      
      ;set centroid-attraction (centroid-attraction * attraction-factor)
      set fd-amt mg-amt-max
      
      
      if (season = 1 or season = 2)
      [
        set energy-loss 4725  ; energy expense * km in Kj
                              ;set energy-loss 45  ; energy expense * km in Kj
      ]
      
      if (season = 0 or season = 4)
      [
        set energy-loss 5512.5  ; energy expense * km in Kj
                                ;set energy-loss 52.5 ; energy expense * km in Kj
      ]
      
      set other-state-found true
    ]
    
    if(state = 1 and not other-state-found);interforage
    [
      set fd-amt fge-amt
      
      if (season = 1 or season = 2)
      [
        set energy-loss 326.025 ;kJ
        ;set energy-loss 3.45 * fd-amt ;* 2.195  ; energy expense * km in Kj
      ]
      
      if (season = 0 or season = 4)
      [
        set energy-loss 374.22 ;kJ
        ;set energy-loss 3.96 * fd-amt ;* 2.195 ; energy expense * km in Kj
      ]
      
      set other-state-found true
    ]
    
    if(state = 0 and not other-state-found) ;Evade
    [
      ;move away from the perceived threat
      ; running distance
      set fd-amt mg-amt-max 
      if (season = 1 or season = 2)
      [
          set energy-loss 4725  ; energy expense * km in Kj
                                ;set energy-loss 45  ; energy expense * km in Kj
      ]
      
      if (season = 0 or season = 4)
      [
        set energy-loss 5512.5  ; energy expense * km in Kj
                                ;set energy-loss 52.5 ; energy expense * km in Kj
      ]
      
      ;;insert code telling caribou to adjust heading away from the disturbance.
      set heading heading + ((random 181) - 270) ;temporary code, randomly adjusts heading anywhere from -90:180
      
      set other-state-found true
    ]
    
    if(state = 3 and not other-state-found) ; rest
    [
      set fd-amt 0
      if (season = 1 or season = 2)
      [
        set energy-loss 205.625 ;kJ, incremental cost relative to intra-forage cost.
        ;set energy-loss 1193.15 ; kJ for a 1.5hour period, laying down (Boertje 1985, 105 kg caribou for 1.5 hrs)
                                ;set energy-loss 1.10894760598 ; kJ for a 1.5hour period, laying down
      ]
      
      if (season = 0 or season = 4)
      [
        set energy-loss 205.625 ;kJ, incremental cost relative to intra-forage cost.
        ;set energy-loss 940.99 ; kJ for a 1.5hour period, laying down (Boertje 1985, 105 kg caribou for 1.5 hrs)
                               ;based on daily average resting of a 105kg caribou
                               ;set energy-loss 0.87458239028 ; kJ for 1.5h period, laying down
      ]
      
    ]
    
    
    ;Move according to state and centroid values
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [ array:set last-patches last-patch-index [caribou-utility-para] of patch-here ]
    [ array:set last-patches last-patch-index [caribou-utility-non-para] of patch-here ]
    
    
    
    set last-patch-index last-patch-index + 1
    
    if(last-patch-index = 45)
      [
        set last-patch-index 0
    ]
    
    
    ;let p patch-list-caribou-wrapper xcor ycor centroid-attraction cent-agent
    let p patch-here
    ;select vegetation based on type
    
    let state-centroid-attraction centroid-attraction
    if(state = 2)
    [
      set state-centroid-attraction state-centroid-attraction * 5 
    ]
    
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [
      set p patch-list-caribou-para-wrapper xcor ycor centroid-attraction current-centroid
    ]
    [
      set p patch-list-caribou-non-para-wrapper xcor ycor centroid-attraction current-centroid
    ]
    
    face p
    set previous-patch p
    ask patch-here
    [
      set caribou-modifier caribou-modifier + caribou-modify-amt
      
      ;Do not let caribou modifer exceed 1
      if(caribou-modifier > 1)
      [
        set caribou-modifier 1
      ]
    ]
    
    ;      ;look 1 patch ahead
    ;      ifelse([elevation] of patch-at-heading-and-distance heading 1 > [elevation] of patch-here)
    ;      [
    ;        ;uphill
    ;        ;0.4556 patch distance = 1km
    ;        set bioenergy bioenergy - (3.640 * weight * (fd-amt / 0.4556))
    ;      ]
    ;      [
    ;        set bioenergy bioenergy - (1.293 * weight * (fd-amt / 0.4556))
    ;      ]
    
    ;let energy-gain 0
    set energy-gain 0
    
    set bioenergy bioenergy - energy-loss ;* caribou-group-number)
    set bioenergy-success bioenergy-success - energy-loss ;* caribou-group-number)
    
    
    ;Move the agent forward by determined amount
    fd fd-amt
    
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [
      if (not (state = 3))
      [
        set energy-gain [caribou-utility-para] of patch-here * energy-gain-factor * caribou-group-number
      ]
    ]
    [
      if (not (state = 3))
      [
        set energy-gain [caribou-utility-non-para] of patch-here * energy-gain-factor * caribou-group-number
      ]
    ]
    
    set bioenergy bioenergy + energy-gain
    set bioenergy-success bioenergy-success + energy-gain
    
    
    ; let acquired-energy caribou-veg-type-energy [vegetation-type] of patch-here * group-size
    ; set bioenergy bioenergy + acquired-energy
    
    
    ;attraction to the current centroid decreases as caribou agents get closer to the centroid.
    ifelse(temp-dist > caribou-cent-dist-cutoff)
    [
      set centroid-attraction centroid-attraction-max
    ]
    [
      set centroid-attraction (temp-dist / caribou-cent-dist-cutoff) * centroid-attraction-max
      if(centroid-attraction < centroid-attraction-min)
      [
        set centroid-attraction centroid-attraction-min
      ]
    ]
    
    
    
    
    ;      if(state = 0)
    ;      [
    ;
    ;
    ;        set test-migration (test-migration - 1)
    ;
    ;        set magic-centroid current-centroid
    ;        let cent-agents centroids with [cid = magic-centroid]
    ;        let cent-agent one-of cent-agents
    ;
    ;        ;patch memory
    ;        let avg-past 0
    ;        let i 0
    ;        while [i < 45]
    ;        [
    ;          set avg-past (avg-past + array:item last-patches i)
    ;
    ;          set i (i + 1)
    ;        ]
    ;        ;Ticks used for testing
    ;        let temp-cent current-centroid
    ;        if(any? centroids in-radius 2 with [cid = temp-cent])
    ;        [
    ;
    ;
    ;          if(last-state-migrate = true)
    ;          [
    ;            set centroid-attraction (centroid-attraction / attraction-factor)
    ;            set last-state-migrate false
    ;            show "END TAXI"
    ;          ]
    ;
    ;
    ;          set avg-past avg-past / 45
    ;          ; show avg-past
    ;          if(avg-past < migrate-val)
    ;          [
    ;            show "TAXI"
    ;            set state 1
    ;          ]
    ;        ]
    ;        array:set last-patches last-patch-index [caribou-utility] of patch-here
    ;        set last-patch-index last-patch-index + 1
    ;
    ;        if(last-patch-index = 45)
    ;        [
    ;          set last-patch-index 0
    ;        ]
    ;
    ;        let p patch-list-caribou-wrapper xcor ycor centroid-attraction cent-agent
    ;
    ;
    ;        face p
    ;        set previous-patch p
    ;        ask patch-here
    ;        [
    ;          set caribou-modifier caribou-modifier + caribou-modify-amt
    ;        ]
    ;        fd fd-amt
    ;      ]
    ;      ;; Migrate
    ;     if (state = 1)
    ;     [
    ;        ;change centroid, used to test until proper centroids implemented
    ;        set current-centroid (random 100 + 1)
    ;        set centroid-attraction (centroid-attraction * attraction-factor)
    ;        ;temporary values to test taxiing
    ;        set test-migration 150
    ;        set state 0
    ;        set last-state-migrate true
    ;
    ;      ]
    
    
    if bioenergy > bioenergy-upper [ set bioenergy bioenergy-upper ]
    if bioenergy < bioenergy-lower [ set bioenergy bioenergy-lower ]  ;adjust working bioenergy values to reasonable limit values. This is to prevent emergence of "super" caribou agents
    ;that have excessive stores of bioenergy.
    
    
  ]
  
end

to go-caribou-q
  let caribou-group-number floor(caribou-amt / caribou-group-amt)

  
  ;;;States;;;
  ; 0 - intra-forage
  ; 1 - taxi
  ; 2 - interforage
  ; 3 - migrate
  
  
  
  ask caribou
  [
    let dist-cent distance current-centroid
    let dist-grid distance grid current-grid
    set state 2
    let other-state-found false
    let avg-past 0
    let energy-l 0
    
    ;close-range ;  ex: 1.2
    ;far-range ; ex: 1.8
    ;fcm-sigmoid-scalar

;wraps into the ternary function

    let close-hunt (min-one-of hunters [distance myself] )
    let hunt-dist-raw distance close-hunt
    
    let hunt-dist fcm-ternary 0.25 0.75 hunt-dist-raw
    let food-dist 0
    let bioenergy-amt 0
    let local-food 0
    let disturb-dist 0
    
    ;TODO: set these ratios
    let rest-ratio bank-rest / 8
    let inter-ratio bank-inter / 2
    let intra-ratio bank-intra / 5
    let migrate-ratio bank-migrate / 1
    ;**************************************************************correct caribou utility logic? *****************************************************************************
    
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-para])
      let high-food-dist distance high-food-near
      
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-para] of high-food-near < 0.5)
      [
        set high-food-dist 129
      ]
     
      set food-dist fcm-ternary 0 3 high-food-dist
      
     
      set bioenergy-amt fcm-ternary bioenergy-lower bioenergy-upper bioenergy
      
      let local-quantity  [caribou-utility-para] of patch-here
      set local-food fcm-ternary 0.50 1 local-quantity ;Foe Close = 0 invert this valuse
     
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist-raw distance close-hunt
     
      set disturb-dist fcm-ternary 1 3 disturb-dist-raw
    ]
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-non-para])
      let high-food-dist distance high-food-near
      
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-non-para] of high-food-near < 0.5)
      [
        set high-food-dist 129
      ]
     
     
      set food-dist (fcm-ternary 0 3 high-food-dist)
      
     
      set bioenergy-amt (fcm-ternary bioenergy-lower bioenergy-upper bioenergy)
      
      let local-quantity  [caribou-utility-para] of patch-here
      set local-food (fcm-ternary 0.50 1 local-quantity)
     
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist-raw distance close-hunt
     
      set disturb-dist (fcm-ternary 1 3 disturb-dist-raw)
     
    ]
    
    
    ;====================================;

    ;set inputs
    
    ;net-x
    matrix:set net-x 0 0 hunt-dist
    matrix:set net-x 0 1 food-dist
    matrix:set net-x 0 2 bioenergy-amt
    matrix:set net-x 0 3 local-food
    matrix:set net-x 0 4 disturb-dist
    matrix:set net-x 0 5 rest-ratio
    matrix:set net-x 0 6 inter-ratio
    matrix:set net-x 0 7 intra-ratio
    matrix:set net-x 0 8 migrate-ratio
    
    set net-s1 matrix:times net-x net-w1
    set net-z1 matrix:map fcm-sigmoid-simple net-s1
    set net-s2 matrix:times net-z1 net-w2
    set net-z2 matrix:map fcm-sigmoid-simple net-s2
    set net-sout matrix:times net-z2 net-wout
    
    let action restrictive-q-softmax net-sout ; action is our state
    ;Action necessary instead of using state directly?
    set state action
    
    
    ;TODO: NEXT STEPS; 
    ; Take the action and record the utility value (reward)
    ;   propagate backwards by : util + gamma * MAX(Q(s_t+1,a))
    ;   where MAX(Q(s_t+1,a)) is the values produced by running of net-sout  ;; Map to independent softmax and save as net-zout?
    
    ;increase taxi/migration based on high values util values

    
    
    ;Centroid Attraction rate
    set magic-centroid current-centroid
    
    let cent-agents centroids with [cid = magic-centroid]
    let cent-agent one-of cent-agents
    let temp-dist (distance current-centroid)
    
    
    ;Check banks
    if(state = 4 and bank-intra = 0)
    [

      set state 3
    ]
    if(state = 3 and bank-rest = 0)
    [

      set state 2
    ]
    if(state = 2 and bank-migrate = 0)
    [

      set state 1
    ]
    if(state = 1 and bank-inter = 0)
    [

      set state 4
    ]
    




      ;other-state-found used to get around if-else limitations
      if(state = 4) ;intra forage
      [
        set fd-amt fga-amt
        set bank-intra bank-intra - 1
        
        set energy-loss  2.82 ; foraging expense
  
        set other-state-found true
      ]

      if(state = 2 and not other-state-found);taxi/migrate
      [
        set bank-migrate bank-migrate - 1
        
       ifelse dist-grid <= 1
      [ select-grid 
        select-centroid ]
      [ if dist-cent <= 1
        [select-centroid ]]
        
        
        ;let closest-cent min-n-of 10 centroids [ distance myself ] 
        ;set current-centroid one-of closest-cent
       ; set current-centroid (random 115 + 1)
        
        ;set centroid-attraction (centroid-attraction * attraction-factor)
        set fd-amt mg-amt-max
        
                
        if (season = 1 or season = 2)
        [
         set energy-loss 45  ; energy expense * km in Kj
        ]
        
        if (season = 0 or season = 4)
        [
         set energy-loss 52.5 ; energy expense * km in Kj
        ]
        
        set other-state-found true
      ]

      if(state = 1 and not other-state-found);interforage
      [
        set fd-amt fge-amt
        set bank-inter bank-inter - 1
        
        if (season = 1 or season = 2)
        [
         set energy-loss 3.45 * fd-amt * 2.195  ; energy expense * km in Kj
        ]
        
        if (season = 0 or season = 4)
        [
         set energy-loss 3.96 * fd-amt * 2.195 ; energy expense * km in Kj
        ]
        
        set other-state-found true
      ]
      
      if(state = 0 and not other-state-found) ;Evade
      [
        ;move away from the perceived threat
        ; running distance
        set other-state-found true
      ]
      
      if(state = 3 and not other-state-found) ; rest
      [
        set bank-rest bank-rest - 1
        set fd-amt 0
        if (season = 1 or season = 2)
        [
         set energy-loss 1.10894760598 ; kJ for a 1.5hour period, laying down
        ]
        
        if (season = 0 or season = 4)
        [
          ;based on daily average resting of a 105kg caribou
         set energy-loss 0.87458239028 ; kJ for 1.5h period, laying down
        ]
        
      ]


      ;Move according to state and centroid values
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [ array:set last-patches last-patch-index [caribou-utility-para] of patch-here ]
    [ array:set last-patches last-patch-index [caribou-utility-non-para] of patch-here ]
    
      
    
      set last-patch-index last-patch-index + 1

      if(last-patch-index = 45)
        [
          set last-patch-index 0
        ]
      
      
      ;let p patch-list-caribou-wrapper xcor ycor centroid-attraction cent-agent
      let p patch-here
      ;select vegetation based on type
      
      let state-centroid-attraction centroid-attraction
      if(state = 2)
      [
        set state-centroid-attraction state-centroid-attraction * 5
      ]
      
      ifelse(caribou-class = 2 and (day > 151 and day < 167))
        [
          set p patch-list-caribou-non-para-wrapper xcor ycor centroid-attraction current-centroid
        ]
        [
          set p patch-list-caribou-para-wrapper xcor ycor centroid-attraction current-centroid
        ]
      face p
      set previous-patch p
      ask patch-here
      [
        set caribou-modifier caribou-modifier + caribou-modify-amt
        
        ;Do not let caribou modifer exceed 1
        if(caribou-modifier > 1)
        [
          set caribou-modifier 1
        ]
      ]
      
      set energy-gain 0
      
      set bioenergy bioenergy - energy-loss ;* caribou-group-number)
      set bioenergy-success bioenergy-success - energy-loss ;* caribou-group-number)

      
      set bioenergy bioenergy - (energy-loss * caribou-group-number)
      

      ;Move the agent forward by determined amount
      fd fd-amt
      
      ifelse(caribou-class = 2 and (day > 151 and day < 167))
      [
        if (not (state = 3))
        [
          set energy-gain [caribou-utility-para] of patch-here * energy-gain-factor * caribou-group-number
        ]
      ]
      [
        if (not (state = 3))
        [
          set energy-gain [caribou-utility-non-para] of patch-here * energy-gain-factor * caribou-group-number
        ]
      ]
      
      set bioenergy bioenergy + energy-gain
      set bioenergy-success bioenergy-success + energy-gain

     ; let acquired-energy caribou-veg-type-energy [vegetation-type] of patch-here * group-size
     ; set bioenergy bioenergy + acquired-energy

      ifelse(temp-dist > caribou-cent-dist-cutoff)
      [
        set centroid-attraction centroid-attraction-max
      ]
      [
        set centroid-attraction (temp-dist / caribou-cent-dist-cutoff) * centroid-attraction-max
        if(centroid-attraction < centroid-attraction-min)
        [
          set centroid-attraction centroid-attraction-min
        ]
      ]
      
      
      
      ;UPDATE THE QNET
      ;set reward to the new patch
      let reward 0
      ifelse(caribou-class = 2 and (day > 151 and day < 167))
        [
          set reward  [caribou-utility-para] of patch-here
        ]
      
        [
          set reward  [caribou-utility-non-para] of patch-here
        ]
      
      
      ;Q_t+1
     let net-xt 0
     ;let net-w1t 0
     let net-s1t 0
     let net-z1t 0
     ;let net-w2t 0
     let net-s2t 0
     let net-z2t 0
     let net-woutt 0
     let net-soutt 0


    set net-xt  matrix:make-constant 1 9 0
    set net-s1t matrix:make-constant 1 9 0
    set net-s2t matrix:make-constant 1 9 0
    set net-z1t matrix:make-constant 1 9 0
    set net-z2t matrix:make-constant 1 9 0
    set net-soutt matrix:make-constant 1 4 0

    set close-hunt (min-one-of hunters [distance myself] )
    set hunt-dist-raw distance close-hunt
    
    set hunt-dist fcm-ternary 0.25 0.75 hunt-dist-raw
    set food-dist 0
    set bioenergy-amt 0
    set local-food 0
    set disturb-dist 0
    
    ;TODO: set these ratios
    set rest-ratio 0
    set inter-ratio 0
    set intra-ratio 0
    set migrate-ratio 0
    
    ifelse(caribou-class = 2 and (day > 151 and day < 167))
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-para])
      let high-food-dist distance high-food-near
      
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-para] of high-food-near < 0.5)
      [
        set high-food-dist 129
      ]
     
      set food-dist fcm-ternary 0 3 high-food-dist
      
     
      set bioenergy-amt fcm-ternary bioenergy-lower bioenergy-upper bioenergy
      
      let local-quantity  [caribou-utility-para] of patch-here
      set local-food fcm-ternary 0.50 1 local-quantity ;Foe Close = 0 invert this valuse
     
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist-raw distance close-hunt
     
      set disturb-dist fcm-ternary 1 3 disturb-dist-raw
    ]
    [
      let high-food-near (max-one-of patches in-radius 3 [caribou-utility-non-para])
      let high-food-dist distance high-food-near
      
      ;If there is no high quantity food nearby, set distance out of the ternary functions range. In this case world-size will do.
      if([caribou-utility-non-para] of high-food-near < 0.5)
      [
        set high-food-dist 129
      ]
     
     
      set food-dist (fcm-ternary 0 3 high-food-dist)
      
     
      set bioenergy-amt (fcm-ternary bioenergy-lower bioenergy-upper bioenergy)
      
      let local-quantity  [caribou-utility-para] of patch-here
      set local-food (fcm-ternary 0.50 1 local-quantity)
     
      let close-disturb (min-one-of hunters [distance myself] )
      let disturb-dist-raw distance close-hunt
     
      set disturb-dist (fcm-ternary 1 3 disturb-dist-raw)
     
    ]
    
    ;Feed Forward Again in new state to get Q_t+1

    
    ;net-xt
    matrix:set net-xt 0 0 hunt-dist
    matrix:set net-xt 0 1 food-dist
    matrix:set net-xt 0 2 bioenergy-amt
    matrix:set net-xt 0 3 local-food
    matrix:set net-xt 0 4 disturb-dist
    matrix:set net-xt 0 5 rest-ratio
    matrix:set net-xt 0 6 inter-ratio
    matrix:set net-xt 0 7 intra-ratio
    matrix:set net-xt 0 8 migrate-ratio
    
    ; Do not use new weights for t+1
    

    
    set net-s1t matrix:times net-xt net-w1
    set net-z1t matrix:map fcm-sigmoid-simple net-s1t
    set net-s2t matrix:times net-z1t net-w2
    set net-z2t matrix:map fcm-sigmoid-simple net-s2t
    set net-soutt matrix:times net-z2t net-wout

    ;Apply Gamma for memory
    set net-soutt matrix:times net-soutt Q-Gamma
    let dout matrix:minus net-soutt net-sout
    
    ;Calculate the error
    let resultSum matrix-element-sum dout
    let q-loss (0.5 * reward + resultSum) ^ 2
    
    ;Calculate using Derivative
    let fp1 matrix:map sigmoid-derivative net-s1
    let fp2 matrix:map sigmoid-derivative net-s2
    
    
    ;To calculate D2 select the appropriate action located in Weights_out, then transpose.
    ;  This will only update the wieghts associated with producing this action.
    ;  In other words, create a 1x9 matrix from the last set of weights to output.
    let waction matrix:submatrix net-wout 0 (state - 1) 9 (state)
    
    
    ;----------------------;PRINT;---------------------;
   ; print matrix:pretty-print-text net-xt
        
   ; print matrix:pretty-print-text (matrix:transpose waction)
   ; print matrix:pretty-print-text net-s2
   ; print matrix:pretty-print-text fp2
   ; print q-loss
   ; print "------------------"
    let d2 matrix:times q-loss matrix:transpose waction
   ; let d2 matrix:times q-loss (fp2)
   
    set d2 matrix:times-element-wise d2 fp2
     
    ;let d1 matrix:times d2 (matrix:times (matrix:transpose net-w2) fp1)
    let d1 matrix:times d2 (matrix:transpose net-w2)
    set d1 matrix:times-element-wise d1 fp1
    
    ;update weights
    ;place our q-value (q-loss) into a matrix the same dimension as the output layer, then take this 
   
    set net-w1 matrix:times (matrix:times (matrix:transpose net-x) d1) (-1 * Q-rate)
    set net-w2 matrix:times (matrix:times (matrix:transpose net-z1) d2) (-1 * Q-rate)
    
    let q-out matrix:make-constant 1 4 1
    matrix:set q-out 0 (state - 1) q-loss
    
    set net-wout matrix:times(matrix:times (matrix:transpose net-z2) q-out) (-1 * Q-rate)
    ]
 

end



to-report matrix-element-sum [matin]
  let matSum 0
  let i 0
  while [i < 4]
  [
   set matSum matrix:get matin 0 i
   
   set i (i + 1)
  ]
  
  report matSum
end
to setup-caribou-q
  ask caribou 
  [ 
    ;initialize weights to 1
    set net-w1 matrix:make-constant 9 9 0
    set net-w2 matrix:make-constant 9 9 0
    set net-wout matrix:make-constant 9 4 0
    
    ;initialize these to anything, they will be overwritten in the go-caribou procedure
    set net-x matrix:make-constant 1 9 0
    set net-s1 matrix:make-constant 1 9 0
    set net-s2 matrix:make-constant 1 9 0
    set net-z1 matrix:make-constant 1 9 0
    set net-z2 matrix:make-constant 1 9 0
    set net-sout matrix:make-constant 1 4 0
  

    
  ]
    
end
to-report sigmoid-derivative [x]
  let temp-x fcm-sigmoid-simple x
  report temp-x * (1 - temp-x)

end

;TODO: Restrictions for migration
to-report restrictive-q-softmax [matin]
  ;reports index of chosen output. Output chosen randomly based on weight calculated by Q (the NN)
  ;assumes you are working with "net-sout"
  
  let zout matrix:make-constant 1 4 0
  
  let found-index 0
  
  let e-sum 0
  let i 0
  while [i < 4]
  [
    let temp matrix:get matin 0 i
    set temp (e ^ temp)
    set e-sum (e-sum + temp)
   ; matrix:set matin  0 i 
    set i (i + 1)
  ]
  
  let stack-sum 0
  set i 0
  while [i < 4]
  [
    let temp matrix:get matin 0 i
    set temp (e ^ temp)
    matrix:set zout 0 i (temp / e-sum)
    set i (i + 1)

  ]
  
  let rand-val (random 10001 / 10000) ; 0 - 1 float value
  set i 0
  while [i < 4]
  [
    let temp matrix:get zout 0 i
    set stack-sum (stack-sum + temp)
    
    if (stack-sum >= rand-val)
    [
      set found-index i
    ]
    
    set i (i + 1)
  ]
  
  report i
  
  
end